/*
 * Copyright 2015-2017 Guillermo Frontera <guillermo.frontera@upm.es>
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */

#include "statistic_output_processor.h"

#include <log/logger.h>

#include <sim/pathfinding/utils.h>

using namespace ues::sim::pf;

const std::string component_name = "Statistical pathfinding output processor";

const float statistic_output_processor::PERCENTILE = 0.95f;


statistic_output_processor::statistic_output_processor ( std::vector< OUTPUT_GENERATOR > generators )
    : generators ( std::move ( generators ) ),
      generator_results ( this->generators.size() ),
      reference_generator ( std::numeric_limits<std::vector<OUTPUT_GENERATOR>::size_type>::max() )
{
}


statistic_output_processor::statistic_output_processor ( std::vector< OUTPUT_GENERATOR > generators,
                                                         OUTPUT_GENERATOR reference )
    : generators ( std::move ( generators ) ),
      generator_results ( this->generators.size() )
{
    std::vector< OUTPUT_GENERATOR >::size_type i = 0;
    bool found = 0;
    while ( i < this->generators.size() && !found )
    {
        if ( this->generators[i] == reference )
        {
            reference_generator = i;
            found = true;
        }
        ++i;
    }
    if ( !found )
    {
        throw ues::exc::exception ( "Reference generator is not included in the list of generators", UES_CONTEXT );
    }
}


void statistic_output_processor::process_output ( const output & out )
{
    for ( std::size_t i = 0; i < out.algorithm_results.size(); ++i )
    {
        generator_results[i].path_lengths.push_back ( out.algorithm_results[i].path.length() );
        generator_results[i].running_times.push_back ( out.algorithm_results[i].running_time );
    }

    if ( reference_generator < generators.size() )
    {
        // Check whether the reference path is actually the shortest path.
        ues::log::logger lg;
        for ( std::size_t i = 0; i < out.algorithm_results.size(); ++i )
        {
            if ( generator_results[i].path_lengths.back() < generator_results[reference_generator].path_lengths.back() - ues::math::epsilon )
            {
                if ( lg.min_level() <= ues::log::WARNING_LVL )
                {
                    ues::log::event e ( ues::log::WARNING_LVL, component_name, "Path is shorter than the reference path" );
                    e.message() << "Path generated by " << describe_output_generator ( generators[i] )
                                << " algorithm is shorter than the reference path by " << describe_output_generator ( generators[reference_generator] ) << " algorithm.\n";
                    e.message() << "Resulting path is: " << out.algorithm_results[i].path << " (length is " << generator_results[i].path_lengths.back() << ").\n";
                    e.message() << "Reference path is: " << out.algorithm_results[reference_generator].path << " (length is " << generator_results[reference_generator].path_lengths.back() << ").\n";
                    lg.record ( std::move ( e ) );
                }
            }
        }
    }
}


void statistic_output_processor::postprocess()
{
    ues::log::logger lg;

    averages.clear ();
    averages.resize ( generators.size() );
    bool relative_path_statistics = reference_generator < generators.size();



    for ( unsigned int i = 0; i < averages.size(); ++i )
    {
        averages[i].sample_size = generator_results[i].path_lengths.size();
        // If a relative path length computation is necessary, perform computation now.
        if ( relative_path_statistics )
        {
            generator_results[i].relative_path_lengths.resize ( averages[i].sample_size );
            for ( unsigned int j = 0; j < averages[i].sample_size; ++j )
            {
                generator_results[i].relative_path_lengths[j] = generator_results[i].path_lengths[j] / generator_results[reference_generator].path_lengths[j];
            }
        }
    }

    if ( lg.min_level() <= ues::log::TRACE_LVL )
    {
        ues::log::event e ( ues::log::TRACE_LVL, component_name, "Raw results of simulation" );
        for ( unsigned int i = 0; i < averages.size(); ++i )
        {
            e.message() << "Information on " << describe_output_generator ( generators[i] ) << " algorithm (" << averages[i].sample_size << " samples):\n";
            for ( unsigned int j = 0; j < averages[i].sample_size; ++j )
            {
                e.message() << "Length: " << generator_results[i].path_lengths[j];
                e.message() << "\t: Time: " << generator_results[i].running_times[j];
                if ( relative_path_statistics )
                {
                    e.message() << "\t: Relative length: " << generator_results[i].relative_path_lengths[j];
                }
                e.message() << '\n';
            }
        }
        lg.record ( std::move ( e ) );
    }

    for ( unsigned int i = 0; i < averages.size(); ++i )
    {
        averages[i].average_path_length = 0;
        averages[i].average_relative_path_length = 0;
        if ( averages[i].sample_size > 0 )
        {
            for ( unsigned int j = 0; j < averages[i].sample_size; ++j )
            {
                averages[i].average_path_length += generator_results[i].path_lengths[j];
                averages[i].average_running_time += generator_results[i].running_times[j];
                if ( relative_path_statistics )
                {
                    averages[i].average_relative_path_length += generator_results[i].relative_path_lengths[j];
                }
            }
            averages[i].average_path_length /= averages[i].sample_size;
            averages[i].average_running_time /= averages[i].sample_size;
            averages[i].average_relative_path_length /= averages[i].sample_size;

            std::sort ( generator_results[i].path_lengths.begin(), generator_results[i].path_lengths.end() );
            std::sort ( generator_results[i].running_times.begin(), generator_results[i].running_times.end() );
            std::sort ( generator_results[i].relative_path_lengths.begin(), generator_results[i].relative_path_lengths.end() );

            unsigned int centile_index = static_cast<unsigned int> ( averages[i].sample_size * PERCENTILE );

            averages[i].centile_path_length = generator_results[i].path_lengths[centile_index];
            averages[i].centile_running_time = generator_results[i].running_times[centile_index];

            if ( relative_path_statistics )
            {
                averages[i].centile_relative_path_length = generator_results[i].relative_path_lengths[centile_index];
            }
        }
    }

    generator_results.clear();
    generator_results.resize ( this->generators.size() );

    if ( lg.min_level() <= ues::log::INFO_LVL )
    {

        ues::log::event e ( ues::log::INFO_LVL, component_name, "Statistical info of simulation available" );
        for ( unsigned int i = 0; i < averages.size(); ++i )
        {
            e.message() << "Information on " << describe_output_generator ( generators[i] ) << " algorithm (" << averages[i].sample_size << " samples):\n";
            e.message() << "\tMean path length: " << averages[i].average_path_length << '\n';
            e.message() << "\tPath length (" << PERCENTILE << " centile): " << averages[i].centile_path_length << '\n';
            if ( relative_path_statistics )
            {
                e.message() << "\tMean path length: " << averages[i].average_relative_path_length << '\n';
                e.message() << "\tPath length (" << PERCENTILE << " centile): " << averages[i].centile_relative_path_length << '\n';
            }
            e.message() << "\tMean running time: " << averages[i].average_running_time << '\n';
            e.message() << "\tRunning time (" << PERCENTILE << " centile): " << averages[i].centile_running_time << '\n';
        }
        lg.record ( std::move ( e ) );
    }
}


const std::vector< OUTPUT_GENERATOR > & statistic_output_processor::get_generators() const
{
    return generators;
}


const std::vector< statistic_output_processor::statistical_data > & statistic_output_processor::get_results() const
{
    return averages;
}

